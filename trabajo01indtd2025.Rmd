---
title: "trabajo01indtd2025"
output: html_document
date: "2025-10-14"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.



```{r, echo=F}
crea.tablaX = function(vector_matporfilas,numalternativas=NULL,numestados=NULL,nb_alternativas=NULL,nb_estados=NULL) {

  if (is.null(numestados) & is.null(numalternativas)) {
    stop('Es necesario proporcionar numalternativas o numestados');
  }
  if (is.null(numestados)) {
    numestados = length(vector_matporfilas)/numalternativas;
  }
  if (is.null(numalternativas)) {
    numalternativas = length(vector_matporfilas)/numestados;
  }

  X = matrix(vector_matporfilas,nrow=numalternativas,ncol=numestados,byrow=TRUE)

  if (!is.null(nb_alternativas)) {
    if (length(nb_alternativas) != numalternativas) {
      stop('El numero de nombres de alternativas no coincide con el numero de alternativas');
    }
    rownames(X) = nb_alternativas;
  } else {
    rownames(X) = paste('d',1:numalternativas,sep='');
  }
  if (!is.null(nb_estados)) {
    if (length(nb_estados) != numestados) {
      stop('El numero de nombres de estados no coincide con el numero de estados');
    }
    colnames(X) = nb_estados;
  } else {
    colnames(X) = paste('e',1:numestados,sep='');
  }
  #colnames(X) = paste('e',1:numestados,sep='');
  #rownames(X) = paste('d',1:numalternativas,sep='');
  return(X);

}

which.min.general = function(vector) {
  minimo = min(vector);
  res = which(vector == minimo);
  return(res);

}

which.max.general = function(vector) {
  maximo = max(vector);
  res = which(vector == maximo);
  return(res);

}

distanciaEuclidea = function(pto1,pto2) {
  return( sqrt( sum( (pto1-pto2)^2 )  ) )
}

criterio.Wald = function(tablaX,favorable=TRUE) { 

  X = tablaX;
  if (favorable) {
      
    AltW = apply(X,MARGIN=1,min); 
    ##AltW
    Wald = max(AltW); 
    Alt_Wald = which.max.general(AltW); 
    metodo = 'favorable';
  } else {
      # caso coste 
    AltW = apply(X,MARGIN=1,max);  
    ##AltW
    Wald = min(AltW); 
    Alt_Wald = which.min.general(AltW); 
    metodo = 'desfavorable';
  }
  resultados = list();
  resultados$criterio = 'Wald'; 
  resultados$metodo = metodo; 
  resultados$tablaX = tablaX; 
  resultados$ValorAlternativas = AltW; 
  resultados$ValorOptimo = Wald; 
  resultados$AlternativaOptima = Alt_Wald; 

  return(resultados);


}

criterio.Optimista = function(tablaX,favorable=TRUE) {

  X = tablaX;

  if (favorable) {
    AltM = apply(X,MARGIN=1,max);
    ##AltM
    Maximax = max(AltM);
    Alt_Maximax = which.max.general(AltM);
    metodo = 'favorable';
  }

  else {
    AltM = apply(X,MARGIN=1,min);
    ##AltM
    Maximax = min(AltM);
    Alt_Maximax = which.min.general(AltM);
    metodo = 'desfavorable';
  }

  resultados = list();
  resultados$criterio = 'Optimista';
  resultados$metodo = metodo;
  resultados$tablaX = tablaX;
  resultados$ValorAlternativas = AltM;
  resultados$ValorOptimo = Maximax;
  resultados$AlternativaOptima = Alt_Maximax;

  return(resultados);


}

criterio.Hurwicz = function(tablaX,alfa=0.3,favorable=TRUE) {
  X = tablaX;

  if (favorable) {
    Altmin = apply(X,MARGIN=1,min); 
    Altmax= apply(X,MARGIN=1,max); 
    AltH = alfa * Altmax + (1-alfa) * Altmin 
    Hurwicz = max(AltH) 
    Alt_Hurwicz = which.max.general(AltH) 
    metodo = 'favorable';
  }

  else {
    Altmin = apply(X,MARGIN=1,min); 
    Altmax= apply(X,MARGIN=1,max); 
    AltH = (1-alfa) * Altmax + alfa * Altmin 
    Hurwicz = min(AltH) 
    Alt_Hurwicz = which.min.general(AltH) 
    metodo = 'desfavorable';
  }

  resultados = list();
  resultados$criterio = 'Hurwicz';
  resultados$alfa = alfa; 
  resultados$metodo = metodo;
  resultados$tablaX = tablaX; 
  resultados$ValorAlternativas = AltH; 
  resultados$ValorOptimo = Hurwicz; 
  resultados$AlternativaOptima = Alt_Hurwicz; 

  return(resultados);
}

dibuja.criterio.Hurwicz_Intervalos = function(tablaX,favorable=TRUE,mostrarGrafico=TRUE) {
    X = tablaX # renombramos la tabla
    Altmin = apply(X,MARGIN=1,min)      
    Altmax = apply(X,MARGIN=1,max)      
    valfa = seq(from=0,to=1,by=0.05)    
    Hurw <- data.frame(Alt_opt = rep(0,length(valfa)),vHurwicz = rep(0,length(valfa)))

    #Alt_opt = rep(0,length(valfa))       

    alfaCorte=c()                       
    for (i in 1:length(valfa)) {
        Opt <- criterio.Hurwicz(X, alfa = valfa[i], favorable)
        Hurw[i,] <-  rbind(Opt$AlternativaOptima[[1]],Opt$ValorOptimo) 
        Alt=c() 
        for (i in 1:dim(Hurw)[1]) {
            valrepetidos = duplicated(Hurw$Alt_opt) 
            if (isFALSE(valrepetidos[i])){
                Alt = c(Alt,Hurw$Alt_opt[i]) 
            }
        }
    }
    # Teniendo el vector de alternativas (Alt) buscamos los puntos de corte de las rectas asociadas a cada alternativa (beneficios)
    # Por ejemplo, la recta que sale de la alternativa a1 y a2 seria:
    #
    #               a1Max *alfa +(1-alfa)*a1Min = a2Max *alfa +(1-alfa)*a2Min
    #
    # Pasando todo a un  miembro e igualando a 0 nos queda:
    #
    #               alfa * (a1Max- a2Max - a1Min + a2Min) + a1Min -a2Min = 0
    #
    # Buscamos ahora los valores de alfa para los que se cortan las rectas asociadas a cada decision
    for (i in 1:(length(Alt)-1)){
        imax = as.numeric(Altmax[Alt[i]])      
        imax1 = as.numeric(Altmax[Alt[i+1]])   
        imin = as.numeric(Altmin[Alt[i]])      
        imin1 = as.numeric(Altmin[Alt[i+1]])   
        if (favorable){
            pCorte = function(alfa) {alfa * (imax-imax1-imin+imin1)+imin-imin1}
            alfaC = uniroot(pCorte, interval = c(0,1))$root[[1]] 
            alfaCorte[i] = alfaC  
        } else {
            # Para el caso de costes (alternativas a1 y a2):
            #
            #               a1Max *(1-alfa) +alfa*a1Min = a2Max *(1-alfa) +alfa*a2Min
            #
            # Pasando todo a un  miembro e igualando a 0 nos queda:
            #
            #               alfa * (a1Min- a2Min - a1Max + a2Max) + a1Max -a2Max = 0
            #
            pCorte = function(alfa) {alfa * (imin-imin1-imax+imax1)+imax-imax1}
            alfaC = uniroot(pCorte, interval = c(0,1))$root[[1]] 
            alfaCorte[i] = alfaC  # Almacenamos los valores de alfa para los que las rectas se cortan en alfaCorte
        }

    }

    if (mostrarGrafico) {
        x0=0;x1=1;
        y0 = min(Altmin);
        y1 = max(Altmax);
        rg = y1-y0;
        y0=y0-0.1*rg;y1=y1+0.1*rg;
        plot(c(x0,x1), c(y0,y1), type = "n", xlab = "alpha", ylab = "Criterio Hurwicz");
        nn = length(Altmin);
        colores = rainbow(nn) 
        abline(v=0);
        abline(v=1);
        if (favorable) {
            for (i in 1:nn) {
                aa = Altmin[i];
                bb = (Altmax[i] - Altmin[i]);
                abline(a=aa,b=bb,col=colores[i]);
            }
        } else {
            for (i in 1:nn) {
                aa = Altmax[i];
                bb = (Altmin[i] - Altmax[i]);
                abline(a=aa,b=bb,col=colores[i]);
            }
        }

        lines(valfa,Hurw$vHurwicz,col="green",lty=3,lwd=3)
        abline(v = alfaCorte, col="red")

        if (favorable) {
            legend("bottomright",legend=rownames(X),fill=colores,inset=0.05) 
            title("Criterio de Hurwicz (favorable - línea discontinua)")
        } else {
            legend("topright",legend=rownames(X),fill=colores,inset=0.05) 
            title("Criterio de Hurwicz (desfavorable - línea discontinua)")
        }
    }

    alfaCorte = round(alfaCorte, 3)
    if (length(alfaCorte)==1){
        Int1=paste("(",0,",",alfaCorte,")")
        Int2=paste("(",alfaCorte,",",1,")")
        Soluciones = cbind(c(Int1,Int2),c(Alt[1],Alt[2]))
    } else {
        Int0=paste("(",0,",",alfaCorte[1],")")
        Int1=paste("(",alfaCorte[length(alfaCorte)],",",1,")")
        Int = ""
        Soluciones= c(Int0, Alt[1])
        for (i in 1:(length(alfaCorte)-1)){
            Int[i] = paste("(",alfaCorte[i],",",alfaCorte[i+1],")")
            Soluciones = rbind(Soluciones,c(Int[i],Alt[i+1]))
        }
        Soluciones = rbind(Soluciones,c(Int1,Alt[length(Alt)]))
    }
    colnames(Soluciones)=c("Intervalo","Alternativa")

    resultados = list();
    resultados$AltOptimas = Alt;
    resultados$PuntosDeCorte = alfaCorte;
    resultados$IntervalosAlfa = Soluciones;
    return(resultados)

}

criterio.Savage = function(tablaX,favorable=TRUE) {

  X = tablaX;
  if (favorable) {
    Mejores = apply(X,MARGIN=2,max);
    temp1 = rep(Mejores,dim(X)[1])
    Mmejores = matrix(temp1,nrow=dim(X)[1],ncol=dim(X)[2],byrow=TRUE);
    Pesos = abs(Mmejores-X);
    ##print(Pesos)
    ## Ahora criterio Wald Minimax Pesimista (desfavorable)
    AltWS= apply(Pesos,MARGIN=1,max);
    Savage = min(AltWS);
    Alt_Savage = which.min.general(AltWS);
    metodo = 'favorable';
  } else {
    Mejores = apply(X,MARGIN=2,min);
    temp1 = rep(Mejores,dim(X)[1])
    Mmejores = matrix(temp1,nrow=dim(X)[1],ncol=dim(X)[2],byrow=TRUE);
    Pesos = abs(Mmejores-X);
    ## Ahora criterio Wald Minimax (desfavorable)
    AltWS= apply(Pesos,MARGIN=1,max);
    Savage = min(AltWS);
    Alt_Savage = which.min.general(AltWS);
    metodo = 'desfavorable';
  }
  resultados = list();
  resultados$criterio = 'Savage';
  resultados$metodo = metodo;
  resultados$tablaX = tablaX;
  resultados$Mejores = Mejores;
  resultados$Pesos = Pesos;
  resultados$ValorAlternativas = AltWS;
  resultados$ValorOptimo = Savage;
  resultados$AlternativaOptima = Alt_Savage;

  return(resultados);

}

criterio.Laplace = function(tablaX,favorable=TRUE) {

  X = tablaX;
  if (favorable) {
    AltL = apply(X,MARGIN=1,mean);
    Laplace = max(AltL) # favorable
    Alt_Laplace = which.max.general(AltL)
    metodo = 'favorable';
  } else {
    AltL = apply(X,MARGIN=1,mean);
    Laplace = min(AltL) # desfavorable
    Alt_Laplace = which.min.general(AltL)
    metodo = 'desfavorable';
  }
  resultados = list();
  resultados$criterio = 'Laplace';
  resultados$metodo = metodo;
  resultados$tablaX = tablaX;
  resultados$ValorAlternativas = AltL;
  resultados$ValorOptimo = Laplace;
  resultados$AlternativaOptima = Alt_Laplace;

  return(resultados);

}

criterio.PuntoIdeal = function(tablaX,favorable=TRUE) {

  X = tablaX;
  if (favorable) {
    MejoresPT = apply(X,MARGIN=2,max); # favorable
    AltPT = rep(0,dim(X)[1])
    for (i in 1:dim(X)[1]) {
      AltPT[i] = distanciaEuclidea(MejoresPT,X[i,])
    }
    ##AltPT
    names(AltPT) = rownames(tablaX)
    PuntoIdeal = min(AltPT);
    Alt_PuntoIdeal = which.min.general(AltPT);
    metodo = 'favorable';
  } else {
    MejoresPT = apply(X,MARGIN=2,min); # desfavorable
    AltPT = rep(0,dim(X)[1])
    names(AltPT) = rownames(tablaX)
    for (i in 1:dim(X)[1]) {
      AltPT[i] = distanciaEuclidea(MejoresPT,X[i,])
    }
    ##AltPT
    PuntoIdeal = min(AltPT);
    Alt_PuntoIdeal = which.min.general(AltPT);
    metodo = 'desfavorable';
  }
  resultados = list();
  resultados$criterio = 'Punto Ideal';
  resultados$metodo = metodo;
  resultados$tablaX = tablaX;
  resultados$Mejores = MejoresPT;
  resultados$ValorAlternativas = AltPT;
  resultados$ValorOptimo = PuntoIdeal;
  resultados$AlternativaOptima = Alt_PuntoIdeal;

  return(resultados);

}

criterio.Todos = function(tablaX,alfa=0.3,favorable=TRUE) {

  cri01 = criterio.Wald(tablaX,favorable);
  cri02 = criterio.Optimista(tablaX,favorable);
  cri03 = criterio.Hurwicz(tablaX,alfa,favorable);
  cri04 = criterio.Savage(tablaX,favorable);
  cri05 = criterio.Laplace(tablaX,favorable);
  cri06 = criterio.PuntoIdeal(tablaX,favorable);

  numestados = ncol(tablaX)
  numalterna = nrow(tablaX)

  resultado = cbind(tablaX,cri01$ValorAlternativas,cri02$ValorAlternativas,
                    cri03$ValorAlternativas,cri04$ValorAlternativas,
                    cri05$ValorAlternativas,cri06$ValorAlternativas);

  decopt = c(rep(NA,numestados),cri01$AlternativaOptima[1],
             cri02$AlternativaOptima[1],cri03$AlternativaOptima[1],
             cri04$AlternativaOptima[1],cri05$AlternativaOptima[1],
             cri06$AlternativaOptima[1]);

  resultado = rbind(resultado,decopt);

  colnames(resultado)[numestados+1] = cri01$criterio;
  colnames(resultado)[numestados+2] = cri02$criterio;
  colnames(resultado)[numestados+3] = cri03$criterio;
  colnames(resultado)[numestados+4] = cri04$criterio;
  colnames(resultado)[numestados+5] = cri05$criterio;
  colnames(resultado)[numestados+6] = cri06$criterio;

  if (favorable) {
    rownames(resultado)[numalterna+1] = 'iAlt.Opt (fav.)';
  } else {
    rownames(resultado)[numalterna+1] = 'iAlt.Opt (Desfav.)';
  }

  ## nuevo
  resultado = as.data.frame(resultado)
  resultado = format(resultado,digits=4)
  decopt = c(rep('--',numestados),
             paste0(names(cri01$AlternativaOptima),collapse = ","),
             paste0(names(cri02$AlternativaOptima),collapse = ","),
             paste0(names(cri03$AlternativaOptima),collapse = ","),
             paste0(names(cri04$AlternativaOptima),collapse = ","),
             paste0(names(cri05$AlternativaOptima),collapse = ","),
             paste0(names(cri06$AlternativaOptima),collapse = ","));

  contar_alternativas = c(names(cri01$AlternativaOptima),
    names(cri02$AlternativaOptima),
    names(cri03$AlternativaOptima),
    names(cri04$AlternativaOptima),
    names(cri05$AlternativaOptima),
    names(cri06$AlternativaOptima))
  f1 = factor(contar_alternativas, levels = rownames(tablaX))
  conteo = as.data.frame(table(f1))
  ind_mejor = which.max.general(conteo[,2])

  alt_mejor = paste0(as.character(conteo[ind_mejor, 1]), collapse = ",")
  resultado = cbind(resultado, c(conteo[,2],NA))
  colnames(resultado)[ncol(resultado)] = "Veces Optima"
  decopt = c(decopt, alt_mejor)

  resultado[nrow(resultado),] = decopt
  ## fin nuevo

  return(resultado)

}



```

## PROBLEMA 1:
Una empresa de ropa sevillana debe decidir donde comenzar a expandir su negocio en otras cuidades.

Las alternativas son d1=Cáceres, d2=Madrid, d3=Cádiz.

El éxito depende del comportamiento del mercado en estas zonas. Pueden considerarse tres situaciones: e1=Baja demanda, e2=Demanda media, e3=Alta demanda.

Los beneficios esperados se esperan en la siguiente tabla en miles de euros:

```{r}
tb1<- crea.tablaX(c(30,70,90, 50,80,60, 90,40,20), numalternativas = 3, numestados = 3)
tb1
```

Los costes esperados se muestran en la siguiente tabla:

```{r}
tb12<- crea.tablaX(c(90,50,30, 80,40,60, 20,70,90), numalternativas = 3, nb_alternativas = c("Cáceres", "Madrid", "Cádiz"), nb_estados=c("baja_demanda", "demanda_media", "alta_demanda"))
tb12
```


FAVORABLE
```{r}
criterio.Wald(tb1, favorable = TRUE)
```

Según el criterio de Wald, lo mejor es seleccionar la alternativa 2, es decir, poner la nueva tienda en Madrid.

```{r}
criterio.Optimista(tb1, favorable = TRUE)
```

Según el criterio optimista tenemos dos posibles soluciones óptimas, la alternativa 1 y la 3, es decir, poner la nueva tienda en Cáceres y en Cádiz.

para alfa=0.5
```{r}
criterio.Hurwicz(tb1, alfa = 0.5, favorable = TRUE)
```

```{r}
dibuja.criterio.Hurwicz_Intervalos(tb1, favorable = TRUE, T)
```

Según el criterio de Hurwicz, para un valor de alfa entre 0 y 0.667 la mejor alternativa es la 2 (poner la nueva tienda en Madrid), y para alfa entre 0.667 y 1 la mejor alternativa es la 1 (poner la nueva tienda en Cáceres)

```{r}
criterio.Savage(tb1, favorable = TRUE)
```

Según el criterio de Savage la alternativa óptina es la segunda, es decir, poner la nueva tienda en Madrid

```{r}
criterio.PuntoIdeal(tb1, favorable = TRUE)
```

Según el criterio PuntoIdeal la mejor opción es la alternativa 2, es decir, poner la nueva tienda en Madrid

```{r}
criterio.Laplace(tb1, favorable =T)
```

Según el criterio de Laplace tenemos dos posibles soluciones óptimas, la alternativa 1 y la 2, es decir, poner la nueva tienda en Cáceres y en Madrid


DESFAVORABLE
```{r}
criterio.Wald(tb12, favorable = F)
```

Según el criterio de Wald la mejor opción es la alternativa dos, es decir, poner la nueva tienda en Madrid

```{r}
criterio.Optimista(tb12, favorable = F)
```

Según el criterio de Optimista la mejor opción es la alternativa tres, es decir, poner la nueva tienda en Cádiz

para alfa=0.5
```{r}
criterio.Hurwicz(tb12, alfa = 0.5, favorable = F)
```

```{r}
dibuja.criterio.Hurwicz_Intervalos(tb12, favorable = F, T)
```

Según el criterio de Hurwicz, para un valor de alfa entre 0 y 0.333 la mejor alternativa es la 2 (poner la nueva tienda en Madrid), y para alfa entre 0.333 y 1 la mejor alternativa es la 3 (poner la nueva tienda en Cádiz)

```{r}
criterio.Savage(tb12, favorable = F)
```

Según el criterio de Savage tenemos dos posibles soluciones óptimas, la alternativa 2 y la 3, es decir, poner la nueva tienda en Madrid y en Cádiz.

```{r}
criterio.PuntoIdeal(tb12, favorable = F)
```

Según el criterio Punto ideal tenemos dos posibles soluciones óptimas, la alternativa 2 y la 3, es decir, poner la nueva tienda en Madrid y en Cádiz.

```{r}
criterio.Laplace(tb12, favorable =F)
```

Según el criterio de Laplace la mejor opción es la alternativa uno, es decir, poner la nueva tienda en Cáceres


## PROBLEMA 2:
En una cuidad se está planteando restringir el uso de coches en el centro de esta para reducir las emisiones contaminantes. Las autoridades deben decidir qué vehículos podrán acceder a la zona restringida.

Tenemos tres alternativas sobre a que vehículos permitir el acceso: a1=sólo residentes de la zona, a2=solo coches eléctricos, a3=todos los coches.

La decisión dependerá de las condiciones de los tipos de coches, representadas por tres posibles estados de la naturaleza: e1=año de fabricación, e2=tipo de combustible, e3=nivel de emisiones medio.
Los costes asociados (en miles de euros) representan el gasto que tendría el Ayuntamiento en medidas complementarias (control, señalización, incentivos, mantenimiento, etc.) según la alternativa elegida y el estado del entorno.

```{r}
tb2<- crea.tablaX(c(500,700,800, 900,600,400, 300,800,1000), numalternativas = 3)
tb2
```

para alfa=0.5
```{r}
criterio.Todos(tb2, alfa=0.5, favorable = F)
```

Aplicando todos los criterios a nuestro problema consideramos que la alternativa 1 (permitir acceso a la zona restringida solo a los residentes de esta) es 4 veces óptima, la alternativa 2 (permitir acceso solo a coche eléctricos) es 2 veces óptima y la alternativa 3 (permitir acceso a todos los coches) es 2 veces óptima. Por tanto, la mejor alternativa es la 1.
